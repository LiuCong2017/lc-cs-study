# 第一章 操作系统简介
### 第一节 什么是操作系统
> - 1. 用户与硬件之间的接口
> - 2. 资源的管理者
> 
>>> - 2.1 处理机管理
>>> - 2.2 内存管理
>>> - 2.3 设备管理
>>> - 2.4 文件管理

### 第二节 操作系统的发展
> - 1. 无操作系统
> - 2. 单道批处理系统
> - 3. 多道程序系统
> - 4. 微机操作系统
> - 5. 实时操作系统
> - 6. 批处理系统、分时系统、实时系统的特点
> 
>>> - 6.1 单道批处理系统的特点
>>> - 6.2 多道批处理系统的特点
>>> - 6.3 分时系统的特点
>>> - 6.4 实时系统的特点

> - 7. 操作系统产品现状

### 第三节 操作系统的特征
> - 1. **并发**
> - 2. **共享**
> - 3. **虚拟**
> - 4. **异步性**

### 第四节 操作系统的功能
> - 1. 内存管理
> 
>> - (1) 内存分配
>> - (2) 内存保护
>> - (3) 地址映射
>> - (4) 内存扩充 

> - 2. 进程管理
> - 3. 设备管理
>
>> - (1)  缓冲管理
>> - (2)  设备分配
>> - (3)  设备处理
>> - (4)  设备独立性和虚拟设备
>
> - 4. 文件管理
>
>> - (1) 文件存储空间的管理
>> - (2) 目录管理
>> - (3) 文件的读、写管理和存取控制
>
> - 5. 提供用户接口
>
>> - (1) 命令接口
>> - (2) 图形用户接口
>> - (3) 程序接口

### 第五节 操作系统的体系结构
> - 1. 软件体系结构简介
> - 2. 操作系统体系结构的分析
>
>> - (1) 简单的监控程序模型
>> - (2) 单体结构模型
>> - (3) 层次结构模型
>> - (4) 客户/服务器模型与微内核结构
>> - (5) 动态可扩展结构模型

### 第六节 指令的执行
> - 1. 指令周期
> - 2. 取指令和执行指令
> 
>> - (1) 取指令
>> - (2) 执行指令
>
> - 3. 一个实例
> - 4. 指令的执行小结

#第二章 进程管理
### 第一节 进程的描述
> - 1. 程序的并发执行
> 
> > - 1.1 程序的顺序执行
> > - 特点:
> > 
> > > - (1) 顺序性
> > > - (2) 封闭性
> > > - (3) 可再现性

> > - 1.2 程序的并发执行
> > 特点:
> > 
> > > - (1) 间断性
> > > - (2) 失去封闭性
> > > - (3) 不可再现性

> - 2. 进程的概念
> 
> > - 2.1 进程的定义 - 正文段、用户数据段、进程控制块
> > - 2.2 进程的特征
> > > - (1) 并发
> > > - (2) 动态
> > > - (3) 独立
> > > - (4) 异步
> > > - (5) 结构特征
> > 
> > - 2.3 进程与程序的比较
> > > - (1) 进程与程序的区别
> > > - (2) 进程与程序的联系

> - 3. 进程控制块 - 进程实体存在的标志
> 
> > - 3.1 什么是进程控制块(PCB)
> > - 3.2 进程控制块中的信息
> > 
> > > - (1) 进程标识符信息
> > > - (2) 处理机状态信息
> > > - (3) 进程调度信息
> > > - (4) 进程控制信息

> - 4. 进程的状态
> 
> > - 4.1 进程的3种基本状态
> 
> > > - (1) 就绪态
> > > - (2) 执行态
> > > - (3) 阻塞态
>
> > - 4.2 进程状态的转换
> > - 4.3 Linux的进程状态

> - 5. 进程的组织
> 
> > - 5.1 链接方式
> > - 5.2 索引方式
> > - 5.3 进程队列

###第二节 进程的控制
> - 1. 进程的创建
> 
> > 1.1 需要创建新进程的情况: 
> > 
> > > - (1) 用户登录
> > > - (2) 作业调度
> > > - (3) 提供服务
> > > - (4) 应用请求

> - 2. 进程的阻塞
> 
> > 情况：
> > 
> > > - (1) 请求系统服务
> > > - (1) 启动某种操作
> > > - (1) 新数据尚未到达
> > > - (1) 无新工作可做
>
> - 3. 进程的唤醒
> 
> > 过程：
> > > - (1)
> > > - (2)
> > > - (3)
> > 
> - 4. 进程的终止
> 
> > 过程：
> 
> - 5. 操作系统的启动和系统中进程的出现

###第三节 操作系统内核
> - 功能：
> 
> > 1. 支撑功能 
> > 2. 资源管理

##### 一、中断
> - 1. 什么是中断
> - 2. 为什么需要中断
> - 3. 中断的类型
> 
> > - 3.1 同步中断 (内部中断或异常)
> > - 3.2 异步中断 (外部中断)
> > 
> > > - (1) 外部可屏蔽中断
> > > - (2) 外部不可屏蔽中断

> - 4. 引起中断的原因
> - 5. 中断响应
> - 6. 单重中断的处理过程
> - 7. 如何找到中断服务子程序

##### 二、时钟管理
> - 1. 时钟的重要性
> - 2. 计算机系统中的时钟
> - 3. 操作系统的时钟机制
> - 4. Linux时钟

##### 三、系统调用
> - 1. 什么是系统调用
> - 2. 系统调用与一般函数的区别
> 
> > - (1) 用户态执行
> > - (2) 系统态执行
> 
> - 3. 普通函数执行过程实例
> - 4. 系统调用执行过程实例
> - 5. 系统调用的类型
> - 6. Linux中的系统调用举例
> - 7. 操作系统提供系统调用的优点

### 第四节 进程同步
##### 一、进程同步的基本概念
##### 二、 同步机制应遵循的准则
> 
>> - (1) **空闲让进**
>> - (2) **忙则等待**
>> - (3) **有限等待**
>> - (4) **让权等待**

##### 三、 信号量机制
> 
> - 1. 整型信号量机制
> 
> > - (1) 整型信号量的wait和signal操作

	var s integer; //s定义为整型信号量
	wait(s) //用于申请资源
	{
	  while s<=0 do no-op; //整型信号量<=0时循环执行空操作
	  s=s-1
	}
	signal(s) //用于释放资源
	{
	  s=s+1;
	}

> > - (2) 用整型信号量实现进程互斥
> > - (3) 用整型信号量实现进程的协调
> > - (4) Linux中的整型信号量
> > - (5) 对整型信号量机制的总结
> 
> - 2. 记录型信号量机制
> 
> > - (1) 记录型信号量的数据类型
> > - (2) 记录型信号量的wait(s)和signal(s)操作
> > - (3) 对记录型信号量wait(s)和signal(s)的说明
> > - (4) 利用记录型信号量实现互斥
> > - (5) 利用记录型信号量实现"协调"的应用举例
> > - (6) Linux 2.4 内核记录型信号量的实例
> 
> - 3. AND型信号量机制
> 
> > - (1) AND型信号量机制的引入
> > - (2) AND型信号量机制的实现

##### 四、 经典的进程同步问题
> 1. 生产者-消费者问题
> 2. 读者-写者问题

##### 五、管程
> 1. 管程的基本概念
> 2. 管程的应用

###第五节 进程通信
##### 一、共享存储器系统
##### 二、 消息传递系统
##### 三、 管道通信
##### 四、消息缓冲队列

### 第六节 线程
##### 一、线程的描述
##### 二、线程的控制
##### 三、线程的同步
##### 四、线程通信







