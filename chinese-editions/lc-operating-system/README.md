# 第一章 操作系统简介
### 第一节 什么是操作系统
> 1. 用户与硬件之间的接口
> 2. 资源的管理者
>> - 2.1 处理机管理
>> - 2.2 内存管理
>> - 2.3 设备管理
>> - 2.4 文件管理

### 第二节 操作系统的发展
> 1. 无操作系统
> 2. 单道批处理系统
> 3. 多道程序系统
> 4. 微机操作系统
> 5. 实时操作系统
> 6. 批处理系统、分时系统、实时系统的特点
>> - 6.1 单道批处理系统的特点
>> - 6.2 多道批处理系统的特点
>> - 6.3 分时系统的特点
>> - 6.4 实时系统的特点
> 7. 操作系统产品现状

### 第三节 操作系统的特征
> 1. **并发**
> 2. **共享**
> 3. **虚拟**
> 4. **异步性**

### 第四节 操作系统的功能
> 1. 内存管理
>> - (1) 内存分配 - 静态、动态
>> - (2) 内存保护
>> - (3) 地址映射
>>> - 3.1) 逻辑地址与物理地址
>>> - 3.2) 地址映射
>> - (4) 内存扩充
>>> - 4.1) 请求调入 
>>> - 4.2) 置换
> 2. 进程管理
> 3. 设备管理
>> - (1)  缓冲管理
>> - (2)  设备分配
>> - (3)  设备处理
>> - (4)  设备独立性和虚拟设备
> 4. 文件管理
>> - (1) 文件存储空间的管理
>> - (2) 目录管理
>> - (3) 文件的读、写管理和存取控制
> 5. 提供用户接口
>> - (1) 命令接口
>> - (2) 图形用户接口
>> - (3) 程序接口

### 第五节 操作系统的体系结构
> 1. 软件体系结构简介
> 2. 操作系统体系结构的分析
>> - (1) 简单的监控程序模型
>> - (2) 单体结构模型
>> - (3) 层次结构模型
>> - (4) 客户/服务器模型与微内核结构
>> - (5) 动态可扩展结构模型

### 第六节 指令的执行
> 1. 指令周期 - 取指周期、执行周期
> 2. 取指令和执行指令
>> - (1) 取指令
>> - (2) 执行指令
> 3. 一个实例
>> - 程序计数器(PC) - 存指令地址
>> - 指令寄存器(IR) - 存正在执行的指令
>> - 累加器(AC) - 临时存储体和累加操作
> 4. 指令的执行小结


# 第二章 进程管理
### 第一节 进程的描述
> 1. 程序的并发执行
> 
> > - 1.1 程序的顺序执行
> > - 特点:
> > 
> > > - (1) 顺序性
> > > - (2) 封闭性
> > > - (3) 可再现性

> > - 1.2 程序的并发执行 - 指在同一时间间隔内运行多个程序
> >
> > 特点:
> > > - (1) 间断性
> > > - (2) 失去封闭性
> > > - (3) 不可再现性

> 2. 进程的概念
> 
> > - 2.1 进程的定义 - 正文段、用户数据段、进程控制块
> > > - 正文段 - 存放被执行的机器指令 
> > > - 用户数据段 - 存放进程在执行时直接进行操作的用户数据
> > > - 进程控制块 - 存放程序的运行环境
> > - 2.2 进程的特征
> > > - (1) 并发
> > > - (2) 动态
> > > - (3) 独立
> > > - (4) 异步
> > > - (5) 结构特征
> > 
> > - 2.3 进程与程序的比较
> > > - (1) 进程与程序的区别
> > > - (2) 进程与程序的联系

> 3. 进程控制块(PCB) - 进程实体存在的标志，每个进程有唯一的进程控制块
> 
> > - 3.1 什么是进程控制块(PCB)
> > - 3.2 进程控制块中的信息
> > > - (1) 进程标识符信息
> > >
> > > - (2) 处理机状态信息
> > > > - 通用寄存器
> > > > - 指令计数器
> > > > - 程序状态字PSW
> > > > - 栈指针 
> > > >
> > > - (3) 进程调度信息
> > > - (4) 进程控制信息

> 4. 进程的状态
> 
> > - 4.1 进程的3种基本状态
> > > - (1) 就绪态: 一旦获得CPU就可以投入运行
> > > - (2) 执行态: 获得CPU，正在运行 
> > > - (3) 阻塞态: 由于等待资源或某个事件的发生而暂停执行
>
> > - 4.2 进程状态的转换
> > > - 时间片: 在CPU上连续运行的时间长度
> > > - 就绪态 <- [时间片] -> 执行态 - [阻塞] -> 阻塞态 - [唤醒] -> 就绪态
> > - 4.3 Linux的进程状态

> 5. 进程的组织
> > - 5.1 链接方式
> > - 5.2 索引方式
> > - 5.3 进程队列

### 第二节 进程的控制
> 1. 进程的创建
> 
> > 1.1 需要创建新进程的情况:
> > > - (1) 用户登录
> > > - (2) 作业调度
> > > - (3) 提供服务
> > > - (4) 应用请求
> >
> > 1.2 创建步骤
> > > - (1) 申请空白PCB 
> > > - (2) 为新进程分配资源
> > > - (3) 初始化进程控制块
> > > - (4) 将新进程插入就绪队列

> 2. 进程的阻塞
> > 情况：
> > > - (1) 请求系统服务
> > > - (2) 启动某种操作
> > > - (3) 新数据尚未到达
> > > - (4) 无新工作可做
> >
> > 过程：
> > > - (1) 状态改为阻塞态
> > > - (2) 插入相应的阻塞队列
> > > - (3) 转进程调度程序，从就绪进程中选择进程为其分配CPU
>
> 3. 进程的唤醒
> > 过程：
> > > - (1) 从阻塞队列中移除
> > > - (2) 状态由阻塞态改为就绪态
> > > - (3) 插入就绪队列
> > 
> 4. 进程的终止
> > - 级联终止: 一个进程终止，其所有子进程也被终止
> >
> > 过程：
> > > - (1) 从进程PCB中读进程状态
> > > - (2) 若进程正在执行，则终止进程的执行
> > > - (3) 若进程有子孙进程，在大多数情况下需要终止子孙进程
> > > - (4) 释放资源
> > > - (5) 将终止进程的PCB移出
> 
> 5. 操作系统的启动和系统中进程的出现
> > 5.1 Linux系统从硬盘引导、加载、初始化和创建进程的过程

### 第三节 操作系统内核
> - 功能：
> > 1. 支撑功能 - 中断操作、时钟管理、原语操作(原子操作)
> > 2. 资源管理 - 进程管理、存储管理、设备管理

##### 一、中断
> 1. 什么是中断 - 改变处理器执行指令顺序
> 2. 为什么需要中断 - 支持异步性
> 3. 中断的类型
> > - 3.1 同步中断 (内部中断或异常) - 由CPU控制单元产生，在一条指令终止后才中断
> > - 3.2 异步中断 (外部中断) - 其它硬件设备随机产生
> > > - (1) 外部可屏蔽中断 - I/O设备产生的中断
> > > > - IRQ - 中断请求
> > > > - PIC - 可编程中断控制器
> > > - (2) 外部不可屏蔽中断 - 紧急事件引起的中断，如硬件故障

> 4. 引起中断的原因
> > - (1) 人为设置中断
> > - (2) 程序性事故
> > - (3) 硬件故障
> > - (4) I/O设备
> > - (5) 外部事件
> 5. 中断响应 - 条件 & 时机
> 6. 单重中断的处理过程
> > - 单重中断的处理流程
> > > - CPU在反复执行指令的过程中，每执行完一条指令，都会检测是否有外部中断信号的到来
> > > - 如果检测到有中断信号，则转中断处理过程
> > > > - (1) 关中断，保护断点
> > > > - (2) 转中断处理程序，完成保护现场(硬件上下文)
> > > > - (3) 根据中断向量找到中断向量表(中断描述符表,IDT)得到入口地址执行中断服务子程序完成中断处理
> > > > - (4) 恢复现场，开中断，CPU返回断点处继续执行被中断的程序
> 7. 如何找到中断服务子程序
> > - (1) 中断向量
> > - (2) 中断描述符表(IDT)

##### 二、时钟管理
> 1. 时钟的重要性 - 脉搏
> 2. 计算机系统中的时钟 - 实时时钟 & OS时钟
> > - PIT : 可编程间隔定时器
> 3. 操作系统的时钟机制
> > 3.1 两种定时测量
> > > - 保存当前的日期和时间
> > > - 维持定时器
> > >
> > 3.2 定时测量功能实现
> > > - (1) OS时钟管理硬件(可编程间隔定时器PIT)
> > > - (2) 时钟软件 - 时钟驱动程序
> > > > - 功能：
> > > > > 1) 维护日期和时间
> > > > > 2) 递减当前进程在一个时间片内的剩余执行时间，并检查是否为0，防止运行超时
> > > > > 3) 对CPU的使用情况记账
> > > > > 4) 递减报警计数器
> 4. Linux时钟

##### 三、系统调用
> 1. 什么是系统调用 - 系统程序与用户程序之间的接口
> 2. 系统调用与一般函数的区别
> > - (1) 用户态执行 - CPU执行用户空间的代码
> > > 用户空间: 用户进程所处的地址空间
> > - (2) 系统态执行 - CPU执行系统核心代码
> > > 系统空间：含有一切系统核心代码的地址空间
> > - 区别
> > > 1) 系统调用运行在系统态(核心态)，一般函数运行在用户态
> > > 2) 执行过程不同
> > > 3) 系统调用要进行"中断处理"，比一般函数调用多些系统开销
> 3. 普通函数执行过程实例
> 4. 系统调用执行过程实例
> 5. 系统调用的类型
> > - (1) 进程控制 
> > - (2) 文件操纵
> > - (3) 设备管理
> > - (4) 通信
> > - (5) 信息维护
> 6. Linux中的系统调用举例
> 7. 操作系统提供系统调用的优点

### 第四节 进程同步
##### 一、进程同步的基本概念
> 两个任务：
> > 1. 保证具有资源共享关系的进程以互斥的方式访问临界资源
> > > - 临界资源:必须以互斥方式访问的共享资源
> > > - 临界区: 进程中访问临界资源的那段代码
> > > - 执行临界区代码实现对临界资源的访问
> > 2. 保证具有相互合作关系的进程协调执行

##### 二、 同步机制应遵循的准则
> 
>> - (1) **空闲让进** - 临界资源空闲，让进程进入临界区
>> - (2) **忙则等待** - 临界资源正被访问，其它访问进程等待
>> - (3) **有限等待** - 给定有限时间，避免无限等待
>> - (4) **让权等待** - 申请不到资源访问，释放处理机，避免"忙等"

##### 三、 信号量机制
> 1. 整型信号量机制
> > - (1) 整型信号量的wait和signal操作

	var s integer; //s定义为整型信号量
	wait(s) //用于申请资源
	{
	  while s<=0 do no-op; //整型信号量<=0时循环执行空操作
	  s=s-1
	}
	signal(s) //用于释放资源
	{
	  s=s+1;
	}

> > - (2) 用整型信号量实现进程互斥

    p
    { //mutex为互斥信号量
      wait(mutex); //等待资源
        CS; //访问临界资源CS
      signal(mutex); //释放资源
    }

> > - (3) 用整型信号量实现进程的协调

    parbegin
        begin p1; signal(s); end
        /**
         * 如果p1不执行或还没执行完，s=0,wait(s)中的while循环条件满足，
         * 因此一直循环，使得控制流不能执行到p2;
         * p1执行完,signal(s)操作，s=1, wait(s)中的while循环结束，wait(s)执行完毕，
         * 才能执行s2;
         */
        begin wait(s); p2; end
    parend

> > - (4) Linux中的整型信号量
> > > 自旋锁: 用来在多处理器环境中工作的一种特殊的锁
> > - (5) 对整型信号量机制的总结
> > > - [1] 整型信号量的值只能由wait和signal操作改变
> > > - [2] wait和signal操作都是原子操作(不可中断)
> > > - [3] 原子操作可通过关中断(CPU不能执行其它进程)实现
> > > - [4] 整型信号量机制的实例：Linux中的自旋锁SpinLock
> > > - [5] 不同的资源对应不同的信号量
> 2. 记录型信号量机制
> > - (1) 记录型信号量的数据类型
    
    Type semaphore=record
        Value: integer; //资源数量
        L: list of process; //阻塞队列

> > - (2) 记录型信号量的wait(s)和signal(s)操作

    procedure wait(s)
      var s: semaphore;
      begin
        s.value = s.value-1;
        //资源分配完毕，进程调用block自我阻塞,进程控制块插入到阻塞队列s.L中
        if s.value<0 then block(s.L);
      end

    procedure signal(s)
      var s: semaphore;
      begin
        s.value = s.value+1;
        //若释放资源(+1)后，s.value<=0,表示仍有进程被阻塞，则调用wakeup唤醒s.L中的一个阻塞进程
        if s.value<=0 then wakeup(s.L);
      end


> > - (3) 对记录型信号量wait(s)和signal(s)的说明
> > > - 当s.value>=0, s.value为资源数量; s.value<0,s.value绝对值为阻塞进程数量
> > > - 每次wait(s)操作，s.value=s.value-1(请求资源),当s.value<0,资源分配完毕
> > > - 每次signal(s)操作,s.value=s.value+1(释放资源,可用资源数+1)
> > > - 若s.value初值为1，表示只允许一个进程访问临界资源，此时信号量为互斥信号量
> > > - 优点是不存在"忙等"，属于"让权等待"

> > - (4) 利用记录型信号量实现互斥

    var s: semaphore;
    s.value = 1;
    Begin
      Repeat
        wait(s);
          Critical Section; //临界区
        signal(s);
        Remainder section; //剩余区
     Until false; //退出Repeat
    End

> > - (5) 利用记录型信号量实现"协调"的应用举例
> > - (6) Linux 2.4 内核记录型信号量的实例

> 3. AND型信号量机制 - 避免死锁
> > - (1) AND型信号量机制的引入
> > > 所需资源全部分配，使用完一起释放，如果不能全部分配，则都不分配(要么全部分配，要么一个都不分配)
> > - (2) AND型信号量机制的实现

    //为不同的共享资源设定相应的信号量s1,s2,...,sn
    Swait(s1,s2,...,sn) //调用Swait申请资源
      if s1>=1 and ... sn>=1 then
        for i=1 to n do si=si-1 //把资源全部分配
      end for
    else //有资源不能分配
    则把进程插入Si阻塞队列，并把程序计数器的值赋为Swait的起始地址
    end if
    
    Signal(s1,s2,...,sn)
      For i=1 to n do
        Si = Si+1; //把资源全部释放
    将阻塞在Si队列中的进程唤醒，插入就绪队列
    end for

##### 四、 经典的进程同步问题
> 1. 生产者-消费者问题
> > 利用记录型信号量机制实现
> > - (1) 设置一个互斥信号量mutex,用于实现对公共缓冲池对互斥访问，初值为1
> > - (2) 设置两个资源信号量，分别表示可用资源数
> > > - empty: 缓冲池中的空缓冲区数，初值为n
> > > - full: 装有消息的缓冲区数，初值为0(1个缓冲区放1个消息)

    Producer: //生产者
      begin
      repeat
        ...
        produce an item in nextp;
        wait(empty); //申请空缓冲区
        wait(mutex); //申请公共缓冲池的互斥访问权
        buffer(in) = nextp; //将消息放入in指针指向的缓冲区
        in = (in+1) mod n; //in指针指向下一个空缓冲区
        signal(mutex); //释放对公共缓冲池对互斥访问权
        signal(full); //释放消息资源
      until false;
      end

    Consumer: //消费者
      begin
      repeat
        ...
        wait(full); //申请消息
        wait(mutex); //申请公共缓冲池对互斥访问权
        nextc = buffer(out); //从out指针指向对缓冲区中取消息
        out = (out+1) mode n； //out指针指向下一个装有消息对缓冲区
        signal(mutex); //释放对公共缓冲池对互斥访问权
        signal(empty); //释放空缓冲区
        consume item in nextc;
      until false;
      end

> 2. 读者-写者问题
>> - (1) 全局信号量readcount用于对进入共享区对读进程计数
>> - (2) 互斥信号量rmutex用于对多个进程共享对全局变量readcount的互斥访问
>> - (3) 互斥信号量wmutex用于实现读操作与写操作的互斥，以及写操作与写操作的互斥

    writer: //写进程
    begin:
        wiat(wmutex);
    ...
    writing operation;
    ...
        signal(wmutex);
    end;
    
    reader: //读进程
    begin:
        wait(rmutex);
        if readcount=0 then wait (wmutex);
        readcount++;
        signal(rmutex);
        ...
        reading file from D;
        ...
        wait(rmutex);
        readcount--;
        if readcount=0 then signal(wmutex);
        signal(rmutex);
        end;

##### 五、管程
> 1. 管程的基本概念
> > - (1) 管程的定义

    type moniter-name = moniter
        variable declarations;
        procedure entryp1(...)
        begin...end;
        ...
        procedure entrypn(..)
        begin...end;
        begin initialization code;
    end

> > - (2) 对管程的说明



> 2. 管程的应用

### 第五节 进程通信
##### 一、共享存储器系统
##### 二、 消息传递系统
##### 三、 管道通信
##### 四、消息缓冲队列

### 第六节 线程
##### 一、线程的描述
> 1. 线程的概念和分类
> 
> > - (1) 线程的概念
> > - (2) 线程的分类 - 用户级、内核级
> 
> 2. 线程的3种基本状态 - 就绪，运行，阻塞
> 3. 线程控制块（TCB）
> 4. 线程与进程的关系
> 
> > - (1) 资源和调度 - 线程是程序执行的基本单元，进程是拥有资源的基本单元
> > - (2) 地址空间资源
> > - (3) 通信关系
> > - (4) 并发性
> > - (5) 系统开销

##### 二、线程的控制
> 1. 线程创建
> 
> > - (1) 用户线程
> > - (2) 内核线程
> > 
> 2. 线程的终止
> > - (1) 引起线程终止的原因
> > - (2) 线程的终止过程
> 3. 线程的调度与切换
> > - (1) 用户线程的调度与切换
> > - (2) 内核线程的调度与切换
> 4. 线程的阻塞与唤醒
> > - (1) 引起线程阻塞的事件
> > - (2) 用户线程的阻塞与唤醒
> > - (3) 内核线程的阻塞与唤醒

##### 三、线程的同步

##### 四、线程通信










